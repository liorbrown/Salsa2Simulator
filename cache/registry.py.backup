"""Volatile cache registry - in-memory cache configuration management.

This module maintains a volatile dictionary of cache configurations loaded from
Squid configuration at startup. Caches are not persisted to the database as they
are completely replaced on program initialization.
"""
from typing import Dict, List, Optional, Tuple
from config.config import MyConfig


def load_caches(caches_data: List[Tuple[str, str, int]]) -> None:
    """
    Load cache configurations into the volatile registry.
    
    This completely replaces the current registry with fresh data.
    Called at program startup by fill_caches() after parsing squid.conf.
    
    Args:
        caches_data: List of tuples (name, ip, access_cost)
    """
    config = MyConfig()
    caches_registry = {}
    
    for name, ip, access_cost in caches_data:
        caches_registry[name] = {
            'ip': ip,
            'access_cost': int(access_cost)
        }
    
    config.set_key('CACHES_REGISTRY', caches_registry)
def _ensure_loaded() -> None:
    """
    Ensure the volatile registry is populated. This attempts a best-effort
    load by calling `fill_caches()` from `cache.cache_manager` if the
    registry is currently empty. The import and call are done lazily to
    avoid circular imports at module import time. All errors are swallowed
    so callers degrade gracefully.
    """
    config = MyConfig()
    caches_registry = config.get_key('CACHES_REGISTRY')
    if caches_registry:
        return

    try:
        # Local import to avoid circular import at module load time.
        from cache.cache_manager import fill_caches
        try:
            fill_caches()
        except Exception:
            # If filling caches fails (missing file, permissions, etc.), do nothing
            pass
    except Exception:
        # If cache_manager isn't importable in this environment, ignore.
        passxception:
        # If cache_manager isn't importable in this environment, ignore.
        pass
def get_cache(name: str) -> Optional[Dict[str, any]]:
    """
    Get a cache by name from the registry.
    
    Args:
        name: Cache name to retrieve
        
    Returns:
        Dictionary with 'ip' and 'access_cost' keys, or None if not found
    """
    _ensure_loaded()
    config = MyConfig()
    caches_registry = config.get_key('CACHES_REGISTRY') or {}
    return caches_registry.get(name)
    _ensure_loaded()
    return CACHES_REGISTRY.get(name)
def get_all_caches() -> Dict[str, Dict[str, any]]:
    """
    Get all cached configurations.
    
    Returns:
        Copy of the entire registry
    """
    _ensure_loaded()
    config = MyConfig()
    caches_registry = config.get_key('CACHES_REGISTRY') or {}
    return caches_registry.copy()
def get_cache_names() -> List[str]:
    """
    Get all cache names in the registry.
    
    Returns:
        List of cache names
    """
    _ensure_loaded()
    config = MyConfig()
    caches_registry = config.get_key('CACHES_REGISTRY') or {}
    return list(caches_registry.keys())
        List of cache names
    """
    _ensure_loaded()
    return list(CACHES_REGISTRY.keys())


def get_name_by_index(index: int) -> Optional[str]:
    """
    Convert a 1-based index (used in DB.cache_id) to a cache name from the registry.

    Args:
        index: 1-based index of the cache

    Returns:
        Cache name if index is valid, else None
    """
    if index is None:
        return None
    names = get_cache_names()
    if index < 1 or index > len(names):
        return None
    return names[index - 1]


def get_index_by_name(name: str) -> Optional[int]:
    """
    Convert a cache name to a 1-based index used by the DB representation.

    Args:
        name: Cache name

    Returns:
        1-based index if found, else None
    """
    if name is None:
        return None
    names = get_cache_names()
    try:
        return names.index(name) + 1
    except ValueError:
        return None


def get_access_cost_by_index(index: int, default: int = 25) -> int:
    """
    Get access cost by DB-style 1-based index.

    Args:
        index: 1-based cache index
        default: default cost if not found

    Returns:
        Access cost as int
    """
    name = get_name_by_index(index)
    if not name:
def get_cache_names_excluding_miss() -> List[str]:
    """
    Get all cache names. Historically the code treated a special 'miss' cache
    as a penalty indicator; the registry no longer stores a fake 'miss' entry,
    so this returns all real cache names.

    Returns:
        List of cache names
    """
    _ensure_loaded()
    config = MyConfig()
    caches_registry = config.get_key('CACHES_REGISTRY') or {}
    return list(caches_registry.keys())
        List of cache names
    """
    _ensure_loaded()
    return list(CACHES_REGISTRY.keys())


def get_access_cost(cache_name: str, default: int = 25) -> int:
    """
    Get the access cost for a specific cache.
    
    Args:
        cache_name: Name of the cache
        default: Default cost if cache not found
        
    Returns:
        Access cost for the cache, or default value
    """
def get_miss_cost() -> int:
    """
    Get the cost for a cache miss (penalty).
    
    Returns:
        Configured miss penalty (defaults to 25)
    """
    config = MyConfig()
    miss_cost = config.get_key('miss_cost')
    return miss_cost if miss_cost is not None else 25
    Get the cost for a cache miss (penalty).
    
def set_miss_cost(cost: int) -> None:
    """Set the miss penalty cost used when computing total costs.

    Args:
        cost: Numeric penalty cost for misses
    """
    config = MyConfig()
    try:
        config.set_key('miss_cost', int(cost))
    except (TypeError, ValueError):
        # Keep previous value on invalid input
        pass
    global miss_cost
    try:
        miss_cost = int(cost)
def registry_size() -> int:
    """
    Get the number of caches in the registry.
    
    Returns:
        Number of cache entries
    """
    _ensure_loaded()
    config = MyConfig()
    caches_registry = config.get_key('CACHES_REGISTRY') or {}
    return len(caches_registry)
def is_empty() -> bool:
    """
    Check if the registry is empty.
    
    Returns:
        True if no caches loaded, False otherwise
    """
    config = MyConfig()
    caches_registry = config.get_key('CACHES_REGISTRY') or {}
    return not len(caches_registry)
    Check if the registry is empty.
    
    Returns:
        True if no caches loaded, False otherwise
    """
    return not len(CACHES_REGISTRY)
